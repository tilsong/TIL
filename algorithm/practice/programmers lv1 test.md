# 0121 프로그래머스  lv1 모의고사

###### 문제 설명

수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

##### 제한 조건

- 시험은 최대 10,000 문제로 구성되어있습니다.
- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.

##### 입출력 예

| answers     | return  |
| ----------- | ------- |
| [1,2,3,4,5] | [1]     |
| [1,3,2,4,2] | [1,2,3] |

### 내 첫 풀이

의도:

각 수포자의 점수를 카운트하고, 그 카운트를 비교하여 배열에 넣는다.

```java
class Solution {
    public int[] solution(int[] answers) {
        int [][] number = { {1,2,3,4,5}, {2,1,2,3,2,4,2,5},
        {3,3,1,1,2,2,4,4,5,5} };
        int [] rights = new int [3];

//각 수포자 점수 확인
    for(int i =0; i<answers.length; i++){
        for(int j =0; j<number.length; j++){
            }
        }
    }
    //가장 높은 점수 확인하기
    
    return answer;
  }
}
```

#### 틀렸던 이유

1. 일단 끝까지 하지 않았다. 피곤했던 것도 있지만, 오늘 좀 자신이 없었던 것 같다.

2. 수포자들의 점수를 answer과 매치시켜야하는데, 이를 어떤 식으로 반복해야할지가 감이 잡히지가 않았다.

3. 가장 높은 점수를 확인할 때도 서로 비교해야 하나.. 하고 생각했다.

4. 그래서 끝까지 생각하지도 않고 풀이를 보아 버렸다.

   

#### 헷갈렸던 부분

- 반복문을 어떻게 반복시켜야 할지 계산이 잘 안되었다. 이번 패인은 끝까지 하지 않은 것이다.. 잘 모르는 것을 적응해나갈 때 초반에는 느린 것이 당연한 것인데 너무 조급했던 것 같다. 많이 아쉽다.



**수정한 답안**

```java
class Solution {
    public int[] solution(int[] answers) {
        int [][] number = { {1,2,3,4,5}, {2,1,2,3,2,4,2,5},
        {3,3,1,1,2,2,4,4,5,5} };
        int [] rights = new int [3];

//각 수포자 점수 확인
    for(int i =0; i<answers.length; i++){
        for(int j =0; j<number.length; j++){
            if(answers[i]==number[j][i%number[j].length]) {
                rights[j]++;
            }
        }
    }
    //가장 높은 점수 확인하기
    int high=0;
    for(int i =0; i<rights.length; i++){
        if(rights[i]>high){
            high = rights[i];
        }
    }
    //리턴 배열 크기 확인
    int size=0;
    for(int i=0; i<rights.length; i++){
        if(high==rights[i]) size++;
    }
    int [] answer = new int[size];
    
    int k=0;
    for(int i=0; i<rights.length; i++){
        if(rights[i]==high){
            
            answer[k]=i+1;
            k++;
        }
    }
    return answer;
  }
}
```
- 배열 안에서 문제를 잘 풀어냈다고 생각되는 풀이다.
- 조건 배열 인덱스를 일정한 수로 반복하려면 [i%array.length]를 하면 되었다.
- 수들의 크기를 비교하기 위해서, temp를 사용할 수 있다. 한편, 리스트를 사용한 방법도 있었다.



**정리**

- 여러 모로 아쉬운 문제였다. 다음부터는 시간이 조금 많이 걸리더라도, 하나씩 해나갈 수 있도록 해야겠다. 조급해하지 말자. 
- 그리고 리스트나 다른 복잡한 것들을 쓰지 않아도 기본적인 것들로도 충분히 알고리즘을 풀어나갈 수 있음을 기억하자.


